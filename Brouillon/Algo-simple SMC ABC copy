    #ETAPE 1
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import scipy.integrate as integrate\n",
    "from scipy.stats import uniform, norm\n",
    "import scipy.stats as sps\n",
    "from random import choices\n"
 
     #ETAPE 2
    "!pip install gk"

    #ETAPE 3
    "def changementeps(distances, eps, poids, alpha, n):\n",
    "    epsilons = np.sort(distances[distances<eps])[::-1]\n",
    "    nbops = len(epsilons)\n",
    "    print(\"nbops\")\n",
    "    print(nbops)\n",
    "    ESS = 1/sum(poids**2)\n",
    "    k = 0\n",
    "    nouvpoids = poids\n",
    "    while (k<nbops-1):\n",
    "        nouveps = epsilons[k]\n",
    "        a=True\n",
    "        for i in range(n):\n",
    "            if (poids[i] != 0) :   \n",
    "                if (distances[i] > eps) or (distances[i] > nouveps):\n",
    "                    nouvpoids[i]=0\n",
    "                else:\n",
    "                    nouvpoids[i] = 1/distances[i]\n",
    "        nouvpoids = nouvpoids / sum(nouvpoids)\n",
    "        nouvESS = 1/sum(nouvpoids**2)\n",
    "        if nouvESS < (alpha * ESS) :\n",
    "            return(nouveps,nouvpoids,nouvESS)\n",
    "        k += 1\n",
    "    return(eps,poids,ESS)\n",
    "\n",
    "def chgtpar(simui, distancesi, sd, eps, data, dprior, dist, n,i):\n",
    "    var = np.random.multivariate_normal(np.zeros(len(sd)),cov=sd)\n",
    "    nsimu = simui + np.append(np.mean(var),var)\n",
    "    comp = dprior(nsimu)\n",
    "    #for i in range(4):\n",
    "       # nnsimu = simui + np.append(np.mean(var),np.random.multivariate_normal(np.zeros(len(sd)),cov=sd))\n",
    "       # dens = dprior(nnsimu)\n",
    "       # nndistances = dist(nnsimu)\n",
    "       # if (nndistances <= eps) and (dens>comp):\n",
    "       #     comp = dens\n",
    "       #     nsimu = nnsimu\n",
    "    ndistances = dist(nsimu)\n",
    "    u = np.random.uniform(1)\n",
    "    if i==0:\n",
    "        print(\"prior\")\n",
    "        print(dprior(nsimu))\n",
    "        print(dprior(simui))\n",
    "    if ndistances>eps :\n",
    "        return(simui, distancesi)\n",
    "    elif distancesi > eps :\n",
    "        return(nsimu, ndistances)\n",
    "    elif (u < distancesi / ndistances):# * comp / dprior(simui)):\n",
    "        print(\"C\")\n",
    "        return(nsimu, ndistances)\n",
    "    else :\n",
    "        return(simui, distancesi)\n",
    "\n",
    "def smc(data, n, T, objectifeps, alpha, rprior, dprior, dist, l):\n",
    "    simu = rprior(n)\n",
    "    distances = np.apply_along_axis(dist,1,simu)\n",
    "    print(distances)\n",
    "    j=1\n",
    "    poids = np.array([1/n]*n)\n",
    "    ESS = n\n",
    "    eps = np.max(distances)\n",
    "    histeps = [eps]\n",
    "    print(\"simu\")\n",
    "    print(simu)\n",
    "    while ((j<T) and (eps>objectifeps)):\n",
    "        (eps, poids, ESS) = changementeps(distances, eps, poids, alpha, n)\n",
    "        histeps.append(eps)\n",
    "        if (ESS < (1/2*n)) :\n",
    "            simu = np.array(choices(simu, weights = poids, k = n))\n",
    "            poids = np.array([1/n]*n)\n",
    "            ESS = n\n",
    "            distances = np.apply_along_axis(dist,1,simu)\n",
    "        sd = 2*np.cov(np.transpose(simu[:,1:l+1]))\n",
    "        for i in range(n):\n",
    "            if (poids[i] > 0) :\n",
    "                simu[i], distances[i] = chgtpar(simu[i], distances[i], sd, eps, data, dprior, dist, n,i)\n",
    "        print(j,eps)\n",
    "        print(\"simu\")\n",
    "        print(simu)\n",
    "        j += 1\n",
    "    simu = choices(simu, weights = poids, k = n)\n",
    "    #poids = np.array([1/n]*n)\n",
    "    ESS = n\n",
    "    distances = np.apply_along_axis(dist,1,simu)\n",
    "    return(simu, poids, distances, histeps)\n",
    "\n"

    #ETAPE 4
    "l = 50\n",
    "data = np.random.normal(5, 1, (l,1000))\n",
    "\n",
    "def rprior(n):\n",
    "    res = np.zeros((n,l+1))\n",
    "    res[:,0] = np.random.uniform(4,6,size = n)\n",
    "    for i in range(n):\n",
    "        res[i,1:l+1] = np.random.normal(res[i,0],1,l)\n",
    "    return(res)\n",
    "\n",
    "statdata = np.array([np.percentile(data[i], np.arange(10, 91, 10)) for i in range(l)])\n",
    "\n",
    "def dprior(simu):\n",
    "    return(np.sum(norm.pdf(simu[1:l+1], loc=simu[0], scale=1)))\n",
    "\n",
    "lev = np.arange(0.1, 0.91, 0.1)\n",
    "def dist(simu):\n",
    "    s = simu[1:l+1]\n",
    "    quantiles = np.array([sps.norm(s[i],1).ppf(lev) for i in range(l)])\n",
    "    return(np.sum(abs(quantiles - statdata)))\n",
    "\n",
    "smc(data, 50, 150, 50, 0.85, rprior, dprior, dist, l)"

    #ETAPE 5
    "lev = np.arange(0.1, 0.91, 0.1)\n",
    "np.array([[sps.norm(0,1).ppf(lev[j])for j in range(9)] for i in range(20)])"

    #ETAPE 6
    "np.mean(data)"
 
    #ETAPE 7
    "data = np.random.normal(0, 1, (20,l))\n",
    "\n",
    "def rprior(n):\n",
    "    means = np.random.uniform(-10,10,size = n)\n",
    "    res = [0]*n\n",
    "    for i in range(n):\n",
    "        res[i] = np.random.normal(means[i],1,l)\n",
    "    return(res,means)\n",
    "\n",
    "np.array([np.percentile(data[i], np.arange(10, 91, 10)) for i in range(20)])"

    #ETAPE 8
    "l = 50\n",
    "data = np.random.normal(0, 1, (20,l))\n",
    "\n",
    "def rprior(n):\n",
    "    means = np.random.uniform(-10,10,size = n)\n",
    "    res = [0]*n\n",
    "    for i in range(n):\n",
    "        res[i] = np.random.normal(means[i],1,l)\n",
    "    return(res,means)\n",
    "\n",
    "statdata = np.array([np.percentile(data[i], np.arange(10, 91, 10)) for i in range(20)])\n",
    "\n",
    "def dprior(simu):\n",
    "    return(np.sum(norm.pdf(simu, loc=simu[1], scale=1)))\n",
    "\n",
    "def dist(simu):\n",
    "    lev = np.arange(0.1, 0.91, 0.1)\n",
    "    quantiles = np.array([[sps.norm(simu[i],1).ppf(lev[j])for j in range(9)] for i in range(20)])\n",
    "    return(np.sum(abs(quantiles - statdata)))\n",
    "\n",
    "dist(np.random.normal(0, 1, (l)))"

    #ETAPE 9
    "np.tile([1,2,3],(3,1))[:,1:3]\n"

    #ETAPE 10
    "sps.norm(2,1).ppf([0.1,0.2,0.3])"
  