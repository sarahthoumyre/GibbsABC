#ETAPE 1
    "#!pip install arviz\n",
    "#!pip install pymc\n",
    "import arviz as az\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pymc as pm\n",
    "import scipy.integrate as integrate\n",
    "from scipy.stats import uniform, norm\n",
    "import scipy.stats as sps\n",
    "from random import choices\n"
    "!pip install gk"

#ETAPE 2
    "def changementeps(distances, eps, poids, alpha, n):\n",
    "    epsilons = np.sort(distances[distances<eps])[::-1]\n",
    "    #print(epsilons)\n",
    "    nbops = len(epsilons)\n",
    "    print(\"nbops\")\n",
    "    print(nbops)\n",
    "    ESS = 1/sum(poids**2)\n",
    "    k = 0\n",
    "    nouvpoids = poids\n",
    "    while (k<nbops-1):\n",
    "        nouveps = epsilons[k]\n",
    "        a=True\n",
    "        for i in range(n):\n",
    "            if (poids[i] != 0) :   \n",
    "                if (sum(distances[:,i][np.where(distances[:,i] <= eps)]) == 0):\n",
    "                    nouvpoids[i]=0\n",
    "                else:\n",
    "                    nouvpoids[i] = poids[i] * sum(distances[:,i][np.where(distances[:,i] <= nouveps)]) / sum(distances[:,i][np.where(distances[:,i] <= eps)])\n",
    "        nouvpoids = nouvpoids / sum(nouvpoids)\n",
    "        nouvESS = 1/sum(nouvpoids**2)\n",
    "        if nouvESS < (alpha * ESS) :\n",
    "            return(nouveps,nouvpoids,nouvESS)\n",
    "        k += 1\n",
    "    return(eps,poids,ESS)\n",
    "\n",
    "def chgtpar(simui, distancesi, sd, eps, data, dprior, dist, n, means, M):\n",
    "    simu = simui + np.random.multivariate_normal(np.zeros(len(sd)),cov=sd)\n",
    "    #print(simu)\n",
    "    ndistances = np.tile([dist(simu)], M)\n",
    "    u = np.random.uniform(1)\n",
    "    #print(distances, distancesi)\n",
    "    if (u < (sum(ndistances[np.where(ndistances <= eps)] / sum(distancesi[np.where(distancesi <= eps)]) * dprior(simu,means) / dprior(simui,means)))):\n",
    "        return(simu, ndistances)\n",
    "    else :\n",
    "        return(simui, distancesi)\n",
    "\n",
    "def pasnoyau(simu, eps, distances, poids, data, dprior, dist, n, means, M):\n",
    "    sd = 2 * np.cov(np.transpose(simu))\n",
    "    mdistances = np.copy(distances)\n",
    "    for i in range(n):\n",
    "        if (poids[i] > 0) :\n",
    "            simu[i], mdistances[:i] = chgtpar(simu[i], mdistances[:i], sd, eps, data, dprior, dist, n, means, M)\n",
    "    return(simu, mdistances)\n",
    "        \n",
    "\n",
    "def smc(data, n, M, T, objectifeps, alpha, rprior, dprior, dist, l):\n",
    "    simu, means = rprior(n)\n",
    "    distances = np.tile([dist(i) for i in simu],(M,1))\n",
    "    print(distances)\n",
    "    j=1\n",
    "    poids = np.array([1/n]*n)\n",
    "    ESS = n\n",
    "    eps = np.max(distances)\n",
    "    histeps = [eps]\n",
    "    while ((j<T) and (eps>objectifeps)):\n",
    "        (eps, poids, ESS) = changementeps(distances, eps, poids, alpha, n)\n",
    "        histeps.append(eps)\n",
    "        if (ESS < n / 2) :\n",
    "            simu = choices(simu, weights = poids, k = n)\n",
    "            poids = np.array([1/n]*n)\n",
    "            ESS = n\n",
    "            distances = np.tile([dist(i) for i in simu],(M,1))\n",
    "        print(distances.shape)\n",
    "        simu, distances = pasnoyau(simu, eps, distances, poids, data, dprior, dist, n, means, M)\n",
    "        print(j,eps)\n",
    "        j += 1\n",
    "    simu = choices(simu, weights = poids, k = n)\n",
    "    #poids = np.array([1/n]*n)\n",
    "    ESS = n\n",
    "    distances = np.array([dist(i) for i in simu]*M)\n",
    "    return(simu, poids, distances, histeps)\n",
 
 #ETAPE 9
    "l = 50\n",
    "data = np.random.normal(-5, 1, (20,l))\n",
    "\n",
    "def rprior(n):\n",
    "    means = np.random.uniform(-10,10,size = n)\n",
    "    res = [0]*n\n",
    "    for i in range(n):\n",
    "        res[i] = np.random.normal(means[i],1,l)\n",
    "    return(res,means)\n",
    "\n",
    "statdata = np.array([np.percentile(data[i], np.arange(10, 91, 10)) for i in range(20)])\n",
    "\n",
    "def dprior(simu,means):\n",
    "    return(np.sum(norm.pdf(simu, loc=means, scale=1)))\n",
    "\n",
    "def dist(simu):\n",
    "    lev = np.arange(0.1, 0.91, 0.1)\n",
    "    quantiles = np.array([[sps.norm(simu[i],1).ppf(lev[j])for j in range(9)] for i in range(20)])\n",
    "    return(np.sum(abs(quantiles - statdata)))\n",
    "\n",
    "smc(data, 50, 50, 50, 150, 0.9, rprior, dprior, dist, l)\n",
    "           \n",
    "#smc(.,.,.,.,.,.,lambda x : np.random.uniform(size = x),.,l)"

#ETAPE 10
    "np.random.normal(0, 1, (20,l))"
 
#ETAPE 11
    "lev = np.arange(0.1, 0.91, 0.1)\n",
    "np.array([[sps.norm(0,1).ppf(lev[j])for j in range(9)] for i in range(20)])"
 
#ETAPE 12
    "data = np.random.normal(0, 1, (20,l))\n",
    "\n",
    "def rprior(n):\n",
    "    means = np.random.uniform(-10,10,size = n)\n",
    "    res = [0]*n\n",
    "    for i in range(n):\n",
    "        res[i] = np.random.normal(means[i],1,l)\n",
    "    return(res,means)\n",
    "\n",
    "np.array([np.percentile(data[i], np.arange(10, 91, 10)) for i in range(20)])"

#ETAPE 13
    "l = 50\n",
    "data = np.random.normal(0, 1, (20,l))\n",
    "\n",
    "def rprior(n):\n",
    "    means = np.random.uniform(-10,10,size = n)\n",
    "    res = [0]*n\n",
    "    for i in range(n):\n",
    "        res[i] = np.random.normal(means[i],1,l)\n",
    "    return(res,means)\n",
    "\n",
    "statdata = np.array([np.percentile(data[i], np.arange(10, 91, 10)) for i in range(20)])\n",
    "\n",
    "def dprior(simu):\n",
    "    return(np.sum(norm.pdf(simu, loc=simu[1], scale=1)))\n",
    "\n",
    "def dist(simu):\n",
    "    lev = np.arange(0.1, 0.91, 0.1)\n",
    "    quantiles = np.array([[sps.norm(simu[i],1).ppf(lev[j])for j in range(9)] for i in range(20)])\n",
    "    return(np.sum(abs(quantiles - statdata)))\n",
    "\n",
    "dist(np.random.normal(0, 1, (l)))"
 
#ETAPE 14
    "np.tile([1,2,3],(3,1))[:,2]\n"

}
